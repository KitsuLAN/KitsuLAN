### 1. Проблема RPC стримов и браузерного клиента

**Простые unary-вызовы** (CreateGuild, SendMessage, GetHistory и т.д.) подключаются стандартно — расширяешь `rpc/client.go` и добавляешь методы в `app.go`, как уже сделано для `Login`/`Register`.

**Стриминг (`SubscribeChannel`) — особый случай.** Wails не может вернуть Go-стрим напрямую в JS. Схема такая:

```
gRPC stream → горутина в Go → runtime.EventsEmit(ctx, "chat:message", ...) → EventsOn("chat:message", ...) в React
```

То есть в `app.go` будет метод `SubscribeChannel(channelID string)` который запускает горутину, а фронтенд слушает события через Wails runtime.

---

Это вызывает проблемы при будущей реализации чисто браузерного клиента.

Что делать со стримингом

Когда дойдём до web-версии, у нас три реальных варианта:

**1. Connect RPC** (`connectrpc.com/connect-go`) — лучший вариант для KitsuLAN. Это библиотека которая делает gRPC-сервер одновременно совместимым с gRPC, gRPC-Web и Connect-протоколом. Стриминг в браузере работает через SSE. На бекенде минимальные изменения — просто оборачиваем существующие handlers. Typescript-клиент генерируется через `protoc-gen-connect-es`.

**2. gRPC-Web + Envoy** — классический подход, но требует Envoy или `grpcwebproxy` как прослойку. Лишний инфраструктурный компонент — для self-hosted это больно.

**3. Параллельный WebSocket/HTTP API** — написать отдельный `echo`/`chi` сервер рядом с gRPC. Максимальная гибкость, но дублирование логики. Оправдано только если нужен публичный REST API для ботов (Phase 6).

**Рекомендация:** в Phase 5 или 6 добавить `connect-go` поверх существующего кода — это 20-30 строк изменений в `app.go` и один дополнительный порт. Wails-клиент продолжит работать как есть через нативный gRPC.

---
